{"name":"Mesascript","tagline":"Lightweight, ruby-based language that provides a powerful way to make inlists for MESA projects.","body":"MesaScript\r\n==========\r\n\r\n###MESA Requirement!\r\nIn its current state, MesaScript requires MESA rev. 5596 or above. This is due\r\nto a sensitivity to where the `'.inc'` files are stored on earlier versions. If\r\nthere is demand for MesaScript for earlier revisions, I will look into making\r\nit backward compatible.\r\n\r\n###The Short Short Version\r\nTo get up and running fast, skip to installation, then try and use the included\r\nsample file, `sample.rb` (via running `ruby sample.rb` in the command line). The\r\ncomments in `sample.rb` should get you started, especially if you have at least\r\na little Ruby know-how.\r\n###What is MesaScript?\r\nLightweight, Ruby-based language that provides a powerful way to make inlists\r\nfor MESA projects. Really, MesaScript is a DSL (domain-specific language) built\r\non top of Ruby, so Ruby code \"just works\" inside MesaScript (if you're familiar\r\nwith it, think of what SASS is to CSS, but on a smaller scale).\r\n\r\n### What does MesaScript do?\r\nMesaScript provides a way to build inlists for use with\r\n[MESA](http://mesa.sourceforge.net) using Ruby, though you need not know much \r\nat all about Ruby to use it. The main point is that you can use\r\nvariables when creating an inlist, making a reusable template for parameter\r\nspace studies when only a few inlist commands vary between a large number of\r\ninlists. Most, if not all, of what MesaScript does can be done by using MESA's\r\n`run_star_extras` hooks, but for the purposes of documenting what I do with\r\nMESA, I find inlists more enlightening, and I try to stick to high-level\r\nlanguages whenever I can.\r\n\r\nThere are other benefits, too. MesaScript automatically checks your input to\r\nmake sure that the types of arguments you give for various namelist items match\r\nwhat is expected, and the resulting inlist is neatly formatted and sensibly\r\nordered. You can also easily convert an existing inlist to MesaScript for\r\nediting and further generalization. In general, *writing an inlist in*\r\n*MesaScript is no more difficult than writing a normal inlist, but you have far*\r\n*more flexibility*. So why not give it a try?\r\n\r\nIf you know a little Ruby (want to learn? \r\n[Try Ruby here!](http://tryruby.org/levels/1/challenges/0)), the possibilities\r\nare pretty wide open. You could easily make a script that starts with a given\r\nset of parameters, run MESA star, then use the output of that run to dictate a\r\nnew inlist and run, creating a chain (maybe a MESA root find of sorts).\r\n\r\n###Installation\r\nSomeday, I hope to package this as a gem, but for now, it's staying hosted on \r\nGithub, which means you need to install it yourself. Clone or otherwise\r\ndownload the repository somewhere to your home directory with\r\n\r\n    git clone https://github.com/wmwolf/MesaScript.git ~/MesaScript\r\n\t  \r\nor somewhere else to your liking.\r\n\r\nThen, either copy the file `mesa_script.rb` to somewhere along Ruby's path, or\r\nset up another stand-in file that points to your `mesa_script.rb` file in\r\nRuby's path. To find Ruby's path, type\r\n\r\n    ruby -e 'puts $:'\r\n\t  \r\nin your terminal. If Ruby is properly configured, as it is on most modern Unix\r\nsystems, you should see a list of possible directories. Either copy\r\n`mesa_script.rb` there or do what I do and make a new file called\r\n`mesa_script.rb` there and have it just be\r\n\r\n    require '/PATH/TO/YOUR/CLONED/REPOSITORY/mesa_script.rb'\r\n\t  \r\nThis way, if you later update your repo via `git pull`, you won't need to copy\r\n`mesa_script.rb` again. Also, if you'd like to use the included (optional)\r\n`inlist2mesascript` tool, copy that to somewhere along you system's path (\r\n`echo $PATH`). Then type `inlist2mesascript -h` to learn more about that tool.\r\nAs you\r\nmight guess, it takes an existing MESA inlist and converts it to a file in\r\nMesaScript that, if executed by Ruby should produce essentially the same inlist\r\n(good for moving a project to MesaScript).\r\n\r\nTo check if Ruby can see the file, try doing `ruby -e 'require \"mesa_script\"'`.\r\nIf no error occurs, it is working fine.\r\n\r\nFinally, you must have your `MESA_DIR` environment variable set for anything to\r\nwork. The `mesa_script.rb` file generates all the necessary data it needs from\r\nthe MESA source on the fly (this also makes it nearly MESA version\r\nindependent).\r\n\r\n###Basic Usage\r\nThe `mesa_script.rb` file defines just one class, Inlist, which we'll interact\r\nwith primarily through one class method, `make_inlist`. Just put the following\r\nin a file to make a blank inlist:\r\n\r\n    require 'mesa_script'\r\n    \r\n    Inlist.make_inlist('babys_first_inlist') {\r\n      # inlist commands go here\r\n    }\r\n    \r\nThis creates a file called `babys_first_inlist` that will be pretty\r\nboring. It will create three namelists (the usual `star_job`, `controls`, and\r\n`pgstar`) and leaves them blank inside, which is a perfectly acceptable inlist\r\nfor MESA to use, since it has defaults available. Now let's say you put this in\r\na file called `my_first_mesascript.rb` (`.rb` is the extension for Ruby files,\r\nby the way). Then to actually generate the inlist, enter\r\n`ruby my_first_mesascript.rb` at the command line and watch in awe as\r\n`babys_first_inlist` pops into existence. You've created an inlist using\r\nMesaScript, and you did so using fewer lines than it would have taken to\r\nactually make that inlist on your own (technically)!\r\n\r\n###Entering Inlist Commands\r\nMaking blank inlists is boring, so now let's cover how you actually make useful\r\ninlists. For mesa inlists, there are really only two types of declarations:\r\nthose for scalars and those for array. Let's talk about scalars first, since\r\nthey are far more common. Then we'll get to the more complicated array\r\nassignments.\r\n\r\n####Scalar Assignments\r\nAs an example, let's say we want to set the initial mass of our star to 2.0\r\nsolar masses. The inlist command for this is `initial_mass`. In a regular\r\ninlist file, we would need to put this in the proper namelist, `&controls` as\r\n`initial_mass = 2.0`. In MesaScript, there are two ways to do this:\r\n\r\n    initial_mass 2.0    # this\r\n    initial_mass(2.0)   # is the same as this\r\n    \r\nIn Ruby, parentheses are optional for method calls, so either way is\r\nacceptable. Note that unlike in normal inlists, MesaScript doesn't care about\r\nthe namelist this attribute belongs to. It'll figure it out on its own and\r\nplace it appropriately.\r\n\r\n**WARNING**: You *cannot* use the standard inlist notation of\r\n\r\n    initial_mass = 2.0  # DON'T EVER DO THIS EVER EVER EVER\r\n    \r\nit will *not* throw an error, because it will simply set a new Ruby variable\r\ncalled `initial_mass`. (For the person curious as to why I didn't program this\r\nfunctionality in, google something like \"instance_eval setter method\" to\r\ndiscover what took me too long to figure out.)\r\n\r\n####Array Assignments\r\nAs an example, let's say we want to set a lower limit on a certain central \r\nabundance as a stopping condition. Then we would, at the minimum, need to set \r\nthe inlist command `xa_central_lower_limit_species(1) = 'h1'`, for example. In MesaScript, there are three ways to do this:\r\n\r\n    xa_central_lower_limit_species[1] = 'h1'    # These are\r\n    xa_central_lower_limit_species(1, 'h1')     # all the\r\n    xa_central_lower_limit_species 1, 'h1'      # same\r\n\r\n**WARNING**: Again, the standard inlist notation for array assignment will not\r\nwork:\r\n\r\n    xa_central_lower_limit_species(1) = 'h1'    # THIS ENDS IN SADNESS\r\n    \r\nI tried to program this functionality in, and the kind people at \r\n[StackOverflow](http://stackoverflow.com/questions/21036873/how-do-i-write-a-method-to-edit-an-array-hash-using-parentheses-instead-of-squar/21044781?noredirect=1#21044781) kindly but firmly convinced me it was utterly impossible to to with Ruby without writing a parser of my own. Just stick to the bracket syntax or the less natural parentheses/space notations.\r\n\r\n####Other Details\r\nThat's really all you need to know to start making inlists with MesaScript,\r\nthough I should remind you, especially if you aren't familiar with Ruby, about\r\nthe basic types of entries you might use. Most inlist commands are one of the\r\nfollowing: booleans, strings, floats, or integers. \r\n\r\n**Booleans** in Ruby are `true` and `false` (case matters, and no periods). \r\n\r\n**Strings** work the same as in fortran, though\r\nsingle quotes are more \"literal\" than double quotes. Double quotes allow for\r\nescaped characters and string interpolation using the `#{...}` notation, which\r\nmight be useful. For instance,\r\n\r\n    my_mass = 2.0\r\n    initial_mass = my_mass\r\n    save_model true\r\n    save_model_filename \"my_star_#{my_mass}.mod\"\r\n\r\nwill produce (among other things) the line \r\n`save_model_filename = 'my_star_2.0.mod'` in the resulting inlist. Note also the\r\nutility of having the initial mass and the save file name being dependent on a\r\nsingle variable.\r\n\r\n**Integers** are just\r\nintegers (I don't know of a useful literal other than just typing out the\r\nentire number, though you can use underscores to make it clearer, e.g.\r\n`100_000_000` is the same as `100000000` in Ruby).\r\n\r\n**Floats** use an \"e\", and never a \"d\" for an exponential indicator, e.g.\r\n`6.02e23`. Ruby floats have arbitrary precision, so there are no doubles.\r\n\r\nFinally, if a particular command is giving you trouble, you can always just encase what you *want* it to be (i.e. in Fortran lingo) in quotes (obviously this does nothing useful if MesaScript is expecting a string). For example\r\n\r\n    mass_change 1e-7\r\n\r\nwill have the same effect as\r\n\r\n    mass_change '1d-7'\r\n    \r\nsince MesaScript will not try to parse `'1d-7'`. It was expecting a float, but\r\nsince it got a string, it assumes you know better than it.\r\n\r\nA useful tidbit is that methods are case sensitive to a point. They have the\r\nsame \"spelling\" as what is found in the `.inc` file (like\r\n`star/private/star_controls.inc`), but every method has an aliased method that\r\nis the same, but all in lower case, so you don't need to remember the\r\ncapitalization so long as you remember the actual spelling.\r\n\r\nAny Ruby inside the `make_inlist` block will be executed normally, and it can\r\nsee variables named outside of the block. So if you have some basic parameters\r\nthat can determine a large number of inlist commands, you can simply name those\r\nparameters as variables at the top of your MesaScript file and then make the\r\nactual MesaScript code weave them into your inlist appropriately. This way, the\r\nactual parameter changing from inlist to inlist is taken outside of the actual\r\ninlist commands so you don't forget to change a particular command when you\r\nmove on to a different run (like forgetting to change a `LOG_dir`, which I've\r\ndone a few too many times and thus overwriten some data).\r\n\r\n###Deeper and Deeper...\r\nAre you still reading this? Well, you must want to do more. \r\n\r\n###Using Custom Namelists\r\nYou can also make MesaScript know about additional namelists (or forget about\r\nthe standard three). After requiring the `mesa_script` file, you can change the\r\nnamelists it cares about via the following commands (obviously subbing out any\r\nstring containing `'namelist1'` or `'namelist2'` with your own appropriate\r\nstrings):\r\n\r\n    require 'mesa_script'\r\n\r\n    Inlist.namelists = ['namelist1', 'namelist2'] # all namelists you want\r\n    \r\n    # Then indicate the name of the '.inc' files like star/private/star_controls.inc\r\n    Inlist.nt_files  = {\r\n      'namelist1' => 'namelist1_controls.inc',\r\n      'namelist2' => 'namelist2_controls.inc'\r\n    }\r\n    # Then indicate the names of the '.defaults' files like those in star/defaults\r\n    Inlist.d_files = {\r\n      'namelist1' => 'namelist1.defaults,\r\n      'namelist2' => 'namelist2.defaults\r\n    }\r\n    # Then specify the paths to the files\r\n    Inlist.nt_paths ={\r\n      'namelist1' => '/path/to/namelist1_controls.inc',\r\n      'namelist2' => '/path/to/namelist2_controls.inc'\r\n    }\r\n\r\nThat *should* set things up to work with custom namelists, so long as the \r\n`.inc` and `.defaults` files are formatted more or less the same as the \"stock\"\r\nones.\r\n\r\n###Accessing Current Values and Displaying Default Values\r\nPerhaps you want to display a default value in your inlist, but not actually\r\nchange it. Well, most of the assignment methods mentioned earlier\r\nare also getter methods. I haven't mentioned how these methods actually work, so I'll do so now since you're still reading this manifesto.\r\n\r\nThese methods first flag the name of the data category for going into the\r\ninlist. Then if a new value is supplied to them, it changes the value in the\r\n`Inlist` object's internal hash. Then, when all the user-supplied code has been\r\nexecuted, it gathers all the flagged data and formats it into\r\nproperly-formatted namelists, which it then prints out in sequence to the file\r\nname provided by the user. One final note about these methods, they always\r\nreturn the value associated with the inlist object (the new one if you assign\r\nit, or the current/default value if you don't set one).\r\n\r\nSo if you want to access any scalar, just call its method without an argument. \r\nNot only does this return the default value, but it also flags the category for\r\ninclusion in the inlist so\r\n\r\n    save_this_value = initial_mass\r\n    \r\nwill set `save_this_value` to `1.0` (the default value in `controls.defaults`)\r\nunless you had already assigned another value, in which case that would be saved\r\ninstead. Additionally, `initial_mass = 1.0` will appear in the final inlist, \r\neven though we didn't give `initial_mass` a new value. In fact, we could just\r\nhave a line like\r\n\r\n    initial_z\r\n    \r\nthat neither uses the return value nor changes the stored value. This will just\r\nflag `initial_z` for being put in the final inlist. Note that there is\r\ncurrently no way to unflag an inlist item.\r\n\r\nFor arrays, things work like you might expect. Any time any one of the versions\r\nof the array methods are called, that entire array category is staged for\r\ninclusion in the inlist. For example, you could do any of the following:\r\n\r\n    xa_central_lower_limit      # returns a hash of values\r\n    xa_central_lower_limit[1]   # returns the value associated with 1 in the hash\r\n    xa_central_lower_limit(1)   # same as above\r\n    xa_central_lower_limit 1    # same as above\r\n    \r\nNote that these array methods, as indicated, point to hashes (not arrays) of\r\nvalues. So `xa_central_lower_limit_species[1] = 'h1'` would return \r\n`{1 => 'h1'}`.\r\n\r\n##Further Work\r\nI warmly welcome bug reports, feature suggestions, and most all, pull requests!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}